<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer Tic-Tac-Toe</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; }
    .status { margin-bottom: 20px; font-size: 1.2rem; }
    .board {
      display: grid;
      grid-template-columns: repeat(3, 100px);
      gap: 10px;
      margin-bottom: 20px;
    }
    .cell {
      width: 100px;
      height: 100px;
      background: #0f3460;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .cell:hover:not(.taken) { background: #1a4a7a; }
    .cell.taken { cursor: not-allowed; }
    .cell.winner { background: #00d26a; }
    .cell.X { color: #00d4ff; }
    .cell.O { color: #ff6b6b; }
    .controls { display: flex; gap: 10px; margin-bottom: 15px; }
    button {
      padding: 12px 24px;
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary { background: #00d4ff; color: #1a1a2e; }
    .btn-primary:hover { background: #00b8e6; }
    .btn-secondary { background: #4a5568; color: white; }
    .btn-secondary:hover { background: #5a6578; }
    .btn-reset { background: #e94560; color: white; }
    .btn-reset:hover { background: #ff6b8a; }
    .info { margin-top: 20px; color: #888; font-size: 0.9rem; }
    .connected { color: #00d26a; }
    .disconnected { color: #e94560; }
    .reconnecting { color: #f6e05e; }
    
    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.hidden { display: none; }
    .modal {
      background: #1a1a2e;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    .modal h2 { margin-bottom: 20px; }
    .modal input {
      width: 100%;
      padding: 12px;
      font-size: 1rem;
      border: 2px solid #0f3460;
      border-radius: 8px;
      background: #0f3460;
      color: white;
      margin-bottom: 15px;
    }
    .modal input:focus {
      outline: none;
      border-color: #00d4ff;
    }
    .modal .error {
      color: #e94560;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }
    
    /* Stats Panel */
    .stats-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #0f3460;
      padding: 15px;
      border-radius: 10px;
      font-size: 0.9rem;
    }
    .stats-panel h3 { margin-bottom: 10px; font-size: 1rem; }
    .stats-panel .stat { margin: 5px 0; }
    .stats-panel .wins { color: #00d26a; }
    .stats-panel .losses { color: #e94560; }
    .stats-panel .ties { color: #f6e05e; }
    
    /* State screens */
    .screen { display: none; }
    .screen.active { display: block; }
    .screen-loading { text-align: center; }
    .screen-lobby { text-align: center; }
    .screen-game { text-align: center; }
    
    /* Turn indicator */
    .turn-indicator {
      padding: 10px 20px;
      border-radius: 20px;
      margin-bottom: 15px;
      font-weight: bold;
    }
    .turn-indicator.my-turn {
      background: #00d26a;
      color: #1a1a2e;
    }
    .turn-indicator.their-turn {
      background: #4a5568;
    }
    
    /* Connection banner */
    .connection-banner {
      position: fixed;
      top: 0; left: 0; right: 0;
      padding: 10px;
      text-align: center;
      font-weight: bold;
    }
    .connection-banner.connecting { background: #f6e05e; color: #1a1a2e; }
    .connection-banner.disconnected { background: #e94560; color: white; }
    .connection-banner.hidden { display: none; }
    
    /* Players in lobby */
    .players-info {
      margin: 15px 0;
      padding: 10px;
      background: #0f3460;
      border-radius: 8px;
    }
    .players-info .player {
      margin: 5px 0;
    }
    .players-info .player .symbol {
      font-weight: bold;
      margin-right: 10px;
    }
    .players-info .player.X .symbol { color: #00d4ff; }
    .players-info .player.O .symbol { color: #ff6b6b; }
    .players-info .waiting { color: #888; font-style: italic; }
    
    /* Game result banner */
    .result-banner {
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      font-size: 1.5rem;
      font-weight: bold;
    }
    .result-banner.win { background: #00d26a; color: #1a1a2e; }
    .result-banner.lose { background: #e94560; }
    .result-banner.draw { background: #f6e05e; color: #1a1a2e; }
    .result-banner.hidden { display: none; }
    
    /* Responsive */
    @media (max-width: 400px) {
      .board { grid-template-columns: repeat(3, 80px); }
      .cell { width: 80px; height: 80px; font-size: 2.5rem; }
    }
  </style>
</head>
<body>
  <!-- Connection Banner -->
  <div class="connection-banner connecting hidden" id="connectionBanner">Connecting...</div>
  
  <!-- Stats Panel -->
  <div class="stats-panel" id="statsPanel" style="display: none;">
    <h3>ðŸ“Š Your Stats</h3>
    <div class="stat wins">Wins: <span id="statWins">0</span></div>
    <div class="stat losses">Losses: <span id="statLosses">0</span></div>
    <div class="stat ties">Ties: <span id="statTies">0</span></div>
    <div class="stat">Games: <span id="statGames">0</span></div>
    <div class="stat" style="margin-top: 10px;">
      <button id="resetStatsBtn" style="padding: 5px 10px; font-size: 0.7rem; background: #4a5568; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
    </div>
  </div>

  <!-- Username Modal -->
  <div class="modal-overlay hidden" id="usernameModal">
    <div class="modal">
      <h2>ðŸ‘‹ Welcome!</h2>
      <p style="margin-bottom: 15px; color: #888;">Enter your username to play</p>
      <div class="error hidden" id="usernameError"></div>
      <input type="text" id="usernameInput" placeholder="Username" maxlength="20" autocomplete="off">
      <button class="btn-primary" id="usernameSubmit" style="width: 100%;">Let's Play!</button>
    </div>
  </div>

  <!-- Loading Screen -->
  <div class="screen screen-loading active" id="loadingScreen">
    <h1>Tic-Tac-Toe</h1>
    <p class="status">Connecting to server...</p>
  </div>

  <!-- Lobby Screen -->
  <div class="screen screen-lobby" id="lobbyScreen">
    <h1>Tic-Tac-Toe</h1>
    <p style="margin-bottom: 20px;">Hello, <span id="lobbyUsername" style="color: #00d4ff; font-weight: bold;">Player</span>!</p>
    <div class="controls">
      <button class="btn-primary" id="findMatchBtn">Find Match</button>
    </div>
    <p id="queueStatus" style="color: #888; margin-top: 10px;"></p>
  </div>

  <!-- Game Screen -->
  <div class="screen screen-game" id="gameScreen">
    <h1>Tic-Tac-Toe</h1>
    <div class="players-info" id="playersInfo">
      <div class="player X"><span class="symbol">X:</span><span class="name">Waiting...</span></div>
      <div class="player O"><span class="symbol">O:</span><span class="name">Waiting...</span></div>
    </div>
    <div class="turn-indicator their-turn" id="turnIndicator">Waiting for opponent...</div>
    <div class="result-banner hidden" id="resultBanner"></div>
    <div class="board" id="board"></div>
    <div class="controls">
      <button class="btn-secondary" id="rematchBtn" style="display: none;">Rematch</button>
      <button class="btn-secondary" id="findNewBtn" style="display: none;">Find New Game</button>
      <button class="btn-reset" id="leaveBtn">Leave Game</button>
    </div>
  </div>

  <div class="info">
    <span id="connectionStatus" class="disconnected">Disconnected</span> | 
    You are: <span id="mySymbol">-</span>
  </div>

  <script>
    // ========================================================================
    // LOCAL STORAGE UTILITIES
    // ========================================================================
    const Storage = {
      KEYS: {
        CLIENT_ID: 'ttt_clientId',
        USERNAME: 'ttt_username',
        STATS: 'ttt_stats',
      },
      
      // Get or create stable client ID
      getClientId() {
        let clientId = localStorage.getItem(this.KEYS.CLIENT_ID);
        if (!clientId) {
          clientId = 'c_' + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
          localStorage.setItem(this.KEYS.CLIENT_ID, clientId);
        }
        return clientId;
      },
      
      // Username
      getUsername() {
        return localStorage.getItem(this.KEYS.USERNAME) || null;
      },
      
      setUsername(name) {
        const trimmed = name.trim().slice(0, 20);
        if (trimmed.length < 1) return false;
        localStorage.setItem(this.KEYS.USERNAME, trimmed);
        return true;
      },
      
      clearUsername() {
        localStorage.removeItem(this.KEYS.USERNAME);
      },
      
      // Stats
      getStats() {
        const stats = localStorage.getItem(this.KEYS.STATS);
        if (stats) {
          return JSON.parse(stats);
        }
        return { wins: 0, losses: 0, ties: 0, games: 0 };
      },
      
      updateStats(result) {
        const stats = this.getStats();
        stats.games++;
        if (result === 'win') stats.wins++;
        else if (result === 'loss') stats.losses++;
        else if (result === 'tie') stats.ties++;
        localStorage.setItem(this.KEYS.STATS, JSON.stringify(stats));
        this.renderStats();
      },
      
      resetStats() {
        localStorage.setItem(this.KEYS.STATS, JSON.stringify({ wins: 0, losses: 0, ties: 0, games: 0 }));
        this.renderStats();
      },
      
      renderStats() {
        const stats = this.getStats();
        document.getElementById('statWins').textContent = stats.wins;
        document.getElementById('statLosses').textContent = stats.losses;
        document.getElementById('statTies').textContent = stats.ties;
        document.getElementById('statGames').textContent = stats.games;
      },
    };

    // ========================================================================
    // APPLICATION STATE
    // ========================================================================
    const AppState = {
      // Current state
      screen: 'loading', // loading, lobby, game
      connection: 'disconnected', // connecting, connected, disconnected
      
      // Player info
      clientId: null,
      username: null,
      playerId: null,
      symbol: null,
      
      // Game state
      gameState: null,
      inQueue: false,
      queuePosition: 0,
      
      // Match tracking to prevent double-counting
      lastGameResult: null,
      
      // UI elements
      elements: {},
      
      init() {
        this.clientId = Storage.getClientId();
        this.username = Storage.getUsername();
        this.cacheElements();
        Storage.renderStats();
      },
      
      cacheElements() {
        this.elements = {
          connectionBanner: document.getElementById('connectionBanner'),
          connectionStatus: document.getElementById('connectionStatus'),
          usernameModal: document.getElementById('usernameModal'),
          usernameInput: document.getElementById('usernameInput'),
          usernameError: document.getElementById('usernameError'),
          usernameSubmit: document.getElementById('usernameSubmit'),
          loadingScreen: document.getElementById('loadingScreen'),
          lobbyScreen: document.getElementById('lobbyScreen'),
          gameScreen: document.getElementById('gameScreen'),
          lobbyUsername: document.getElementById('lobbyUsername'),
          findMatchBtn: document.getElementById('findMatchBtn'),
          queueStatus: document.getElementById('queueStatus'),
          playersInfo: document.getElementById('playersInfo'),
          turnIndicator: document.getElementById('turnIndicator'),
          resultBanner: document.getElementById('resultBanner'),
          board: document.getElementById('board'),
          rematchBtn: document.getElementById('rematchBtn'),
          findNewBtn: document.getElementById('findNewBtn'),
          leaveBtn: document.getElementById('leaveBtn'),
          mySymbol: document.getElementById('mySymbol'),
          statsPanel: document.getElementById('statsPanel'),
          resetStatsBtn: document.getElementById('resetStatsBtn'),
        };
      },
      
      // Screen management
      showScreen(screenName) {
        this.screen = screenName;
        this.elements.loadingScreen.classList.remove('active');
        this.elements.lobbyScreen.classList.remove('active');
        this.elements.gameScreen.classList.remove('active');
        
        if (screenName === 'loading') this.elements.loadingScreen.classList.add('active');
        else if (screenName === 'lobby') this.elements.lobbyScreen.classList.add('active');
        else if (screenName === 'game') this.elements.gameScreen.classList.add('active');
        
        // Show/hide stats panel
        this.elements.statsPanel.style.display = (screenName === 'lobby' || screenName === 'game') ? 'block' : 'none';
      },
      
      // Connection management
      setConnection(status) {
        this.connection = status;
        this.elements.connectionBanner.classList.remove('hidden', 'connecting', 'disconnected');
        this.elements.connectionStatus.classList.remove('connected', 'disconnected', 'reconnecting');
        
        if (status === 'connecting') {
          this.elements.connectionBanner.classList.add('connecting');
          this.elements.connectionBanner.textContent = 'Connecting...';
          this.elements.connectionStatus.textContent = 'Connecting...';
          this.elements.connectionStatus.classList.add('reconnecting');
        } else if (status === 'connected') {
          this.elements.connectionBanner.classList.add('hidden');
          this.elements.connectionStatus.textContent = 'Connected';
          this.elements.connectionStatus.classList.add('connected');
        } else {
          this.elements.connectionBanner.classList.add('disconnected');
          this.elements.connectionBanner.textContent = 'Disconnected - Reconnecting...';
          this.elements.connectionStatus.textContent = 'Disconnected';
          this.elements.connectionStatus.classList.add('disconnected');
        }
      },
      
      // Update lobby UI
      updateLobby() {
        this.elements.lobbyUsername.textContent = this.username || 'Player';
        
        if (this.inQueue) {
          this.elements.findMatchBtn.textContent = 'Cancel';
          this.elements.queueStatus.textContent = `In queue... Position: #${this.queuePosition}`;
        } else {
          this.elements.findMatchBtn.textContent = 'Find Match';
          this.elements.queueStatus.textContent = '';
        }
      },
      
      // Update game UI
      updateGame() {
        if (!this.gameState) return;
        
        const { board, turn, winner, gameOver, players } = this.gameState;
        
        // Update players
        const playerX = players?.find(p => p.symbol === 'X');
        const playerO = players?.find(p => p.symbol === 'O');
        
        this.elements.playersInfo.innerHTML = `
          <div class="player X"><span class="symbol">X:</span><span class="name">${playerX?.username || (playerX?.id === this.playerId ? (this.username || 'You') : 'Waiting...')}</span></div>
          <div class="player O"><span class="symbol">O:</span><span class="name">${playerO?.username || (playerO?.id === this.playerId ? (this.username || 'You') : 'Waiting...')}</span></div>
        `;
        
        // Update turn indicator
        const isMyTurn = turn === this.symbol;
        this.elements.turnIndicator.classList.remove('my-turn', 'their-turn');
        if (!gameOver) {
          this.elements.turnIndicator.classList.add(isMyTurn ? 'my-turn' : 'their-turn');
          this.elements.turnIndicator.textContent = isMyTurn ? 'ðŸŽ¯ Your turn!' : `Waiting for ${turn}...`;
        }
        
        // Update result banner
        if (gameOver) {
          this.elements.resultBanner.classList.remove('hidden', 'win', 'lose', 'draw');
          
          if (winner === 'draw') {
            this.elements.resultBanner.classList.add('draw');
            this.elements.resultBanner.textContent = "ðŸ¤ It's a draw!";
            
            // Only count once
            if (this.lastGameResult !== 'tie') {
              this.lastGameResult = 'tie';
              Storage.updateStats('tie');
            }
          } else if (winner === this.symbol) {
            this.elements.resultBanner.classList.add('win');
            this.elements.resultBanner.textContent = 'ðŸŽ‰ You win!';
            
            // Only count once
            if (this.lastGameResult !== 'win') {
              this.lastGameResult = 'win';
              Storage.updateStats('win');
            }
          } else {
            this.elements.resultBanner.classList.add('lose');
            this.elements.resultBanner.textContent = 'ðŸ’€ You lose!';
            
            // Only count once
            if (this.lastGameResult !== 'loss') {
              this.lastGameResult = 'loss';
              Storage.updateStats('loss');
            }
          }
          
          // Show rematch buttons
          this.elements.rematchBtn.style.display = 'inline-block';
          this.elements.findNewBtn.style.display = 'inline-block';
        } else {
          this.elements.resultBanner.classList.add('hidden');
          this.elements.rematchBtn.style.display = 'none';
          this.elements.findNewBtn.style.display = 'none';
          this.lastGameResult = null;
        }
        
        // Update board
        const cells = this.elements.board.querySelectorAll('.cell');
        cells.forEach((cell, i) => {
          const val = board[i];
          cell.textContent = val || '';
          cell.className = 'cell' + (val ? ' taken ' + val : '');
          cell.classList.toggle('winner', winner && board[i] === winner);
        });
        
        // Update my symbol display
        this.elements.mySymbol.textContent = this.symbol || '-';
      },
    };

    // ========================================================================
    // WEBSOCKET CONNECTION
    // ========================================================================
    let ws = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;
    const RECONNECT_BASE_DELAY = 1000;

    function getWorkerUrl() {
      // In production, this is replaced by Cloudflare
      return window.WORKER_URL || location.origin;
    }

    function connect() {
      AppState.setConnection('connecting');
      
      const wsUrl = getWorkerUrl().replace(/^http/, 'ws') + '/ws';
      console.log('Connecting to:', wsUrl);
      
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('WebSocket connected');
        reconnectAttempts = 0;
        AppState.setConnection('connected');
        
        // Send handshake with client identity
        send({
          type: 'handshake',
          clientId: AppState.clientId,
          username: AppState.username,
        });
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleMessage(data);
      };

      ws.onclose = () => {
        console.log('WebSocket closed');
        AppState.setConnection('disconnected');
        attemptReconnect();
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
    }

    function attemptReconnect() {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.log('Max reconnect attempts reached');
        return;
      }
      
      reconnectAttempts++;
      const delay = Math.min(RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1), 30000);
      console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);
      
      setTimeout(connect, delay);
    }

    function send(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
      }
    }

    function handleMessage(data) {
      console.log('Received:', data.type, data);
      
      switch (data.type) {
        case 'welcome':
          AppState.playerId = data.playerId;
          AppState.symbol = data.symbol;
          AppState.gameState = data.state;
          AppState.inQueue = data.inQueue || false;
          
          if (AppState.inQueue) {
            AppState.showScreen('lobby');
            AppState.updateLobby();
          } else if (AppState.gameState) {
            AppState.showScreen('game');
            AppState.updateGame();
          } else {
            AppState.showScreen('lobby');
            AppState.updateLobby();
          }
          break;
          
        case 'state':
          AppState.gameState = {
            ...data,
            players: AppState.gameState?.players || [],
          };
          AppState.updateGame();
          break;
          
        case 'queue_update':
          AppState.inQueue = data.inQueue;
          AppState.queuePosition = data.position || 0;
          AppState.updateLobby();
          break;
          
        case 'game_start':
          AppState.symbol = data.symbol;
          AppState.gameState = data.state;
          AppState.inQueue = false;
          AppState.showScreen('game');
          AppState.updateGame();
          break;
          
        case 'match_ended':
          // Clear the game state but stay on game screen to show result
          if (AppState.gameState) {
            AppState.gameState.gameOver = true;
            AppState.gameState.winner = data.winner;
            AppState.updateGame();
          }
          break;
          
        case 'error':
          console.error('Server error:', data.message);
          alert(data.message);
          break;
          
        case 'username_required':
          // Show username modal
          AppState.showScreen('loading');
          showUsernameModal();
          break;
          
        case 'username_accepted':
          AppState.username = data.username;
          Storage.setUsername(data.username);
          AppState.updateLobby();
          break;
      }
    }

    // ========================================================================
    // USERNAME MODAL
    // ========================================================================
    function showUsernameModal() {
      AppState.elements.usernameModal.classList.remove('hidden');
      AppState.elements.usernameInput.value = AppState.username || '';
      AppState.elements.usernameInput.focus();
    }

    function hideUsernameModal() {
      AppState.elements.usernameModal.classList.add('hidden');
    }

    function submitUsername() {
      const username = AppState.elements.usernameInput.value.trim();
      const errorEl = AppState.elements.usernameError;
      
      if (username.length < 1) {
        errorEl.textContent = 'Username is required';
        errorEl.classList.remove('hidden');
        return;
      }
      
      if (username.length > 20) {
        errorEl.textContent = 'Username must be 20 characters or less';
        errorEl.classList.remove('hidden');
        return;
      }
      
      // Basic profanity filter (optional)
      const profanity = ['fuck', 'shit', 'ass', 'damn', 'bitch', 'crap'];
      if (profanity.some(word => username.toLowerCase().includes(word))) {
        errorEl.textContent = 'Please choose a family-friendly username';
        errorEl.classList.remove('hidden');
        return;
      }
      
      errorEl.classList.add('hidden');
      AppState.username = username;
      Storage.setUsername(username);
      hideUsernameModal();
      
      // Send to server
      send({
        type: 'set_username',
        username: username,
        clientId: AppState.clientId,
      });
      
      // Go to lobby
      AppState.showScreen('lobby');
      AppState.updateLobby();
    }

    // ========================================================================
    // GAME ACTIONS
    // ========================================================================
    function findMatch() {
      if (AppState.inQueue) {
        // Cancel queue
        send({ type: 'leave_queue', clientId: AppState.clientId });
        AppState.inQueue = false;
        AppState.updateLobby();
      } else {
        // Find match
        send({
          type: 'find_match',
          clientId: AppState.clientId,
          username: AppState.username,
        });
        AppState.inQueue = true;
        AppState.queuePosition = 0;
        AppState.updateLobby();
      }
    }

    function makeMove(index) {
      if (!AppState.gameState || AppState.gameState.gameOver) return;
      if (AppState.gameState.turn !== AppState.symbol) return;
      if (AppState.gameState.board[index]) return;
      
      send({
        type: 'move',
        index: index,
        clientId: AppState.clientId,
      });
    }

    function rematch() {
      send({
        type: 'rematch',
        clientId: AppState.clientId,
      });
    }

    function findNewGame() {
      AppState.gameState = null;
      AppState.symbol = null;
      AppState.lastGameResult = null;
      send({
        type: 'find_match',
        clientId: AppState.clientId,
        username: AppState.username,
      });
      AppState.inQueue = true;
      AppState.queuePosition = 0;
      AppState.updateLobby();
      AppState.showScreen('lobby');
    }

    function leaveGame() {
      send({
        type: 'leave_game',
        clientId: AppState.clientId,
      });
      AppState.gameState = null;
      AppState.symbol = null;
      AppState.lastGameResult = null;
      AppState.showScreen('lobby');
      AppState.updateLobby();
    }

    // ========================================================================
    // INITIALIZATION
    // ========================================================================
    function init() {
      // Initialize app state
      AppState.init();
      
      // Create board cells
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.addEventListener('click', () => makeMove(i));
        AppState.elements.board.appendChild(cell);
      }
      
      // Event listeners
      AppState.elements.usernameSubmit.addEventListener('click', submitUsername);
      AppState.elements.usernameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitUsername();
      });
      AppState.elements.findMatchBtn.addEventListener('click', findMatch);
      AppState.elements.rematchBtn.addEventListener('click', rematch);
      AppState.elements.findNewBtn.addEventListener('click', findNewGame);
      AppState.elements.leaveBtn.addEventListener('click', leaveGame);
      AppState.elements.resetStatsBtn.addEventListener('click', () => {
        if (confirm('Reset all stats?')) {
          Storage.resetStats();
        }
      });
      
      // Check if username exists
      if (!AppState.username) {
        showUsernameModal();
        AppState.showScreen('loading');
      } else {
        AppState.showScreen('lobby');
        AppState.updateLobby();
      }
      
      // Connect to server
      connect();
    }

    // Start the app
    init();
  </script>
</body>
</html>
